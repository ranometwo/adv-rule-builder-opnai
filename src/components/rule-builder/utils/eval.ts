export const isNumber=(v:any)=>typeof v==='number'&&!Number.isNaN(v); export function evalSimple(cond:any,payload:any){const{field,operator,value}=cond;const v=payload[field]; if(operator==='EXISTS')return v!==undefined&&v!==null; if(operator==='NOT_EXISTS')return v===undefined||v===null; if(v===undefined||v===null)return false; switch(operator){case'==':return Array.isArray(v)?v.includes(value):v===value;case'!=':return Array.isArray(v)?!v.includes(value):v!==value;case'>':return isNumber(v)&&isNumber(value)&&v>value;case'>=':return isNumber(v)&&isNumber(value)&&v>=value;case'<':return isNumber(v)&&isNumber(value)&&v<value;case'<=':return isNumber(v)&&isNumber(value)&&v<=value;case'IN':return Array.isArray(value)?value.includes(v)||(Array.isArray(v)&&v.some((x:any)=>value.includes(x))):false;case'NOT_IN':return Array.isArray(value)?!value.includes(v):false;case'BETWEEN':{if(!Array.isArray(value)||value.length!==2)return false;const[a,b]=value;return isNumber(v)&&isNumber(a)&&isNumber(b)&&v>=a&&v<=b} default:return false}} export function evalGroup(node:any,payload:any,trace:any[]){if(node.type==='simple'){const result=evalSimple(node,payload);trace.push({node,result});return result}const op=node.operator||'ALL'; if(op==='NOT'){const child=node.children[0];const res=!evalGroup(child,payload,trace);trace.push({node,result:res});return res} if(op==='ALL'){for(const c of node.children){const r=evalGroup(c,payload,trace);if(!r){trace.push({node,result:false,shortCircuited:true});return false}}trace.push({node,result:true});return true} for(const c of node.children){const r=evalGroup(c,payload,trace);if(r){trace.push({node,result:true,shortCircuited:true});return true}}trace.push({node,result:false});return false} export function lintFormula(formula:string,knownFields:string[]){const errors:string[]=[]; if(!formula||!formula.trim())return['Formula required'];const idents=(formula.match(/[a-zA-Z_][a-zA-Z0-9_]*/g)||[]).filter(t=>!['min','max','floor','ceil','round'].includes(t)); for(const t of idents){ if(!knownFields.includes(t)&&isNaN(Number(t))){errors.push(`Unknown identifier: ${t}`)}} const opens=(formula.match(/\(/g)||[]).length; const closes=(formula.match(/\)/g)||[]).length; if(opens!==closes)errors.push('Unbalanced parentheses'); if(/\/\s*0(?![0-9])/.test(formula))errors.push('Division by zero risk'); return errors } export function computePoints(formula:string,payload:Record<string,any>){const sandbox={min:Math.min,max:Math.max,floor:Math.floor,ceil:Math.ceil,round:Math.round};const scope={...sandbox,...payload};const fn=new Function(...Object.keys(scope),`return (${formula});`);try{return fn(...Object.values(scope))}catch(e){return null}} export function evaluateFilters(payload:any,filters:any){ if(filters.dateRange.enabled){ if(!filters.dateRange.start||!filters.dateRange.end)return false; const d=new Date(payload.event_date||Date.now()); const s=new Date(filters.dateRange.start); const e=new Date(filters.dateRange.end); if(Number.isNaN(d as any)||Number.isNaN(s as any)||Number.isNaN(e as any))return false; if(d<s||d>e)return false } const geo=filters.geo; const geoChecks:boolean[]=[]; if(geo.zone.length)geoChecks.push(geo.zone.includes(payload.zone)); if(geo.region.length)geoChecks.push(geo.region.includes(payload.region)); if(geo.tty.length)geoChecks.push(geo.tty.includes(payload.tty)); if(geo.pincode.length)geoChecks.push(geo.pincode.includes(String(payload.pincode))); if(geoChecks.length){const ok=geo.operator==='ALL'?geoChecks.every(Boolean):geoChecks.some(Boolean); if(!ok)return false} const prod=filters.product; const prodChecks:boolean[]=[]; if(prod.product_group.length)prodChecks.push(prod.product_group.includes(payload.product_group)); if(prod.category.length)prodChecks.push(prod.category.includes(payload.category)); if(prod.sub_category.length)prodChecks.push(prod.sub_category.includes(payload.sub_category)); if(prod.product_name.length)prodChecks.push(prod.product_name.includes(payload.product_name)); if(prod.sub_brand.length)prodChecks.push(prod.sub_brand.includes(payload.sub_brand)); if(prod.sku_code.length)prodChecks.push(prod.sku_code.includes(String(payload.sku_code))); if(prod.pack_volume.length)prodChecks.push(prod.pack_volume.includes(payload.pack_volume)); if(prodChecks.length){const ok=prod.operator==='ALL'?prodChecks.every(Boolean):prodChecks.some(Boolean); if(!ok)return false} return true }